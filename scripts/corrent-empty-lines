#!/usr/bin/perl

use strict;
use warnings;

sub spacelength {
	my ($line) = @_;
	if ($line =~ /^([\s\t]+)/) {
		return length($1);
	}
	else {
		return 0;
	}
}

sub nonspacelength {
	my ($line) = @_;
	return length($line) - spacelength($line);
}

sub using_key {
	my ($line) = @_;
	if ($line =~ /^Microsoft/i) {
		return 2;
	}
	elsif ($line =~ /^Knot/i) {
		return 4;
	}
	elsif ($line =~ /^System/i) {
		return 1;
	}
	else {
		return 3;
	}
}

sub copyright_lines {
	return (map { $_."\n" } split (/\r?\n/, qq{#region Copyright

/*
 * Copyright (c) 2013-2014 Tobias Schulz, Maximilian Reuter, Pascal Knodel,
 *                         Gerd Augsburg, Christina Erler, Daniel Warzel
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the "Software"), to deal
 * in the Software without restriction, including without limitation the rights
 * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 * copies of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in all
 * copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
 * SOFTWARE.
 */

#endregion
}));
}

my @files = split (/[\r\n]+/, `find -name "*.cs" -or -name "*.template"`);

foreach my $file (@files) {
	print $file."\n";
	open my $fh, "<", $file;
	my @orig_lines = <$fh>;
	close $fh;

	my @lines_above_copyright_notice = ();
	while (my $line = shift @orig_lines) {
		if ($line =~ /^[#]endregion\s*$/) { # if ($line =~ /^\s[*]\/\s*$/) {
			@lines_above_copyright_notice = ();
			last;
		}
		push @lines_above_copyright_notice, $line;
	}
	unshift @orig_lines, @lines_above_copyright_notice;

	my %usings = map { $_ => 1 } map { s/^[^\s]*?using (.*)[;]/$1/gm; s/[\r\n]+//gm; $_ } grep { /^[^\s]*?using (.*)[;]/ } @orig_lines;
	my $temp = join ('', @orig_lines);
	$temp =~ s/#region Using[^#]*#endregion//gm;
	@orig_lines = map { $_.qq{\n} } split (/\n/, $temp);
	@orig_lines = grep { !/^[^\s]*?using (.*)[;]/ } @orig_lines;

	my @sorted_usings = sort { using_key($a) <=> using_key($b) } sort { $a cmp $b } keys %usings;

	my @lines = ();

	push @lines, "#region Using\n";
	push @lines, "\n";
	my $last_key = -1;
	foreach my $using (@sorted_usings) {
		if ($last_key != -1 && $last_key != using_key($using)) {
			push @lines, "\n";
		}
		push @lines, "using ".$using.";\n";
		$last_key = using_key($using);
	}
	push @lines, "\n";
	push @lines, "#endregion\n";

	while (my $line = shift @orig_lines) {
		push @lines, $line;
	}

	for (my $i = 0; $i < @lines; ++$i) {
		if ($lines[$i-1] =~ /^\s*[{]\s*$/ && nonspacelength($lines[$i]) == 0) {# && spacelength($lines[$i]) > spacelength($lines[$i-1])) {
			$lines[$i] = "FUCK";
		}
		if ($lines[$i+1] =~ /^\s*[}]\s*$/ && nonspacelength($lines[$i]) == 0) {# && spacelength($lines[$i]) > spacelength($lines[$i+1])) {
			$lines[$i] = "FUCK";
		}
		if ($lines[$i-1] =~ /[{]\s*$/ && $lines[$i-1] !~ /[}]/ && nonspacelength($lines[$i]) == 0) {# && spacelength($lines[$i]) > spacelength($lines[$i-1])) {
			$lines[$i] = "FUCK";
		}
		if ($lines[$i+1] =~ /[}].?.?.?\s*$/ && $lines[$i+1] !~ /[{]/ && nonspacelength($lines[$i]) == 0) {# && spacelength($lines[$i]) > spacelength($lines[$i+1])) {
			$lines[$i] = "FUCK";
		}
		if ($lines[$i-1] =~ /[(]\s*$/ && $lines[$i-1] !~ /[)]/ && nonspacelength($lines[$i]) == 0) {# && spacelength($lines[$i]) > spacelength($lines[$i-1])) {
			$lines[$i] = "FUCK";
		}
		if ($lines[$i+1] =~ /[)].?.?.?\s*$/ && $lines[$i+1] !~ /[(]/ && nonspacelength($lines[$i]) == 0) {# && spacelength($lines[$i]) > spacelength($lines[$i+1])) {
			$lines[$i] = "FUCK";
		}
		if ($lines[$i-2] =~ /[=][>]\s*$/ && $lines[$i-1] =~ /^\s*[{]\s*$/ && $lines[$i] =~ /^\s*[}][;]\s*$/) {
			chomp $lines[$i-2];
			$lines[$i-2] .= "{};\n";
			$lines[$i-1] = "FUCK";
			$lines[$i] = "FUCK";
		}
		if ($lines[$i-1] =~ /[=][>]\s*$/ && $lines[$i] =~ /^\s*[{][}][;]\s*$/) {
			chomp $lines[$i-1];
			$lines[$i-1] .= "{};\n";
			$lines[$i] = "FUCK";
		}
		if (nonspacelength($lines[$i+1]) == 0 && nonspacelength($lines[$i]) == 0) {
			$lines[$i] = "FUCK";
		}
		if ($lines[$i] =~ /using Microsoft.VisualStudio.TestTools.UnitTesting/) {
			$lines[$i] = "using NUnit.Framework;\n";
		}
		$lines[$i] =~ s/TestClass/TestFixture/gm;
		$lines[$i] =~ s/\[TestMethod\]/\[Test\]/gm;
		$lines[$i] =~ s/([a-zA-Z0-9])\(/$1 (/gm;
	}
	@lines = grep {!/FUCK/} @lines;

	@lines = map { if (/Log.Debug/) { s/.ToString.?\(\)//gm; s/[+]/,/gm; s/\s*?[,]/,/gm; }; $_ } @lines;

	@lines = grep {!/Microsoft.VisualStudio.TestTools/} @lines;

	open my $fh, ">", $file;
	my $content = join('', copyright_lines(), qq[\n], @lines);
	$content =~ tr/\x{feff}//d;
	print $fh $content;
	close $fh;
}
